{
  "version": 3,
  "sources": ["../src/api.ts", "../node_modules/@nfen/webcrypto-ts/src/webcrypto.ts", "../node_modules/@nfen/webcrypto-ts/src/ec/shared.ts", "../node_modules/@nfen/webcrypto-ts/src/proxy.ts", "../node_modules/@nfen/webcrypto-ts/src/sha/shared.ts", "../node_modules/@nfen/webcrypto-ts/src/hmac/index.ts", "../node_modules/@nfen/webcrypto-ts/src/kdf/shared.ts", "../node_modules/@nfen/webcrypto-ts/src/rsa/shared.ts", "../node_modules/@nfen/webcrypto-ts/src/key_usages.ts", "../node_modules/@nfen/webcrypto-ts/src/aes/shared.ts", "../node_modules/@nfen/webcrypto-ts/src/aes/aes_cbc.ts", "../node_modules/@nfen/webcrypto-ts/src/random.ts", "../node_modules/@nfen/webcrypto-ts/src/aes/aes_ctr.ts", "../node_modules/@nfen/webcrypto-ts/src/aes/aes_gcm.ts", "../node_modules/@nfen/webcrypto-ts/src/aes/aes_kw.ts", "../node_modules/@nfen/webcrypto-ts/src/kdf/pbkdf.ts", "../node_modules/@nfen/webcrypto-ts/src/sha/sha_256.ts", "../node_modules/rfc4648/lib/rfc4648.js", "../node_modules/@cfworker/base64url/dist/decode.js", "../node_modules/@cfworker/base64url/dist/encode.js", "../src/utils.ts", "../src/crypto.ts", "../src/dom.ts", "../src/url.ts", "../src/index.ts"],
  "sourcesContent": ["const makeRequest = (endpoint: string, payload: object = {}) =>\n    fetch(\n        new Request(`https://secrets.api.neal.codes/${endpoint}`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(payload),\n        })\n    );\n\ninterface ErrorResponse {\n    status: Number;\n    message: string;\n}\n\nexport namespace API {\n    interface RetrievePayload {\n        id: string;\n    }\n    interface RetrieveResponse {\n        ciphertext: Array<Number>;\n        iv: Array<Number>;\n    }\n    export interface RetrieveUsableResponse {\n        ciphertext: ArrayBuffer;\n        iv: ArrayBuffer;\n    }\n\n    export async function retrieve(payload: RetrievePayload) {\n        const response = await makeRequest(\"retrieve\", payload);\n        if (response.ok) {\n            const { iv, ciphertext } =\n                (await response.json()) as RetrieveResponse;\n            return {\n                iv: Uint8Array.from(iv).buffer,\n                ciphertext: Uint8Array.from(ciphertext).buffer,\n            } as RetrieveUsableResponse;\n        }\n        const error = (await response.json()) as ErrorResponse;\n        throw new Error(error?.message);\n    }\n    interface StorePayload {\n        ciphertext: Array<Number>;\n        iv: Array<Number>;\n    }\n    interface StoreResponse {\n        id: string;\n    }\n\n    export async function store({\n        ciphertext,\n        iv,\n    }: {\n        ciphertext: ArrayBuffer;\n        iv: ArrayBuffer;\n    }) {\n        const payload: StorePayload = {\n            iv: Array.from(new Uint8Array(iv)),\n            ciphertext: Array.from(new Uint8Array(ciphertext)),\n        };\n        const response = await makeRequest(\"store\", payload);\n        if (response.ok) {\n            return (await response.json()) as StoreResponse;\n        }\n        const error = (await response.json()) as ErrorResponse;\n        throw new Error(error?.message);\n    }\n}\n", "/**\n * Wrapper for node/browser webcrypto\n * @module\n */\n\nimport { Alg as SHA } from \"./sha/shared.js\";\n\nclass CryptoLoader {\n    static async load(): Promise<Crypto> {\n        // @ts-ignore\n        return typeof crypto !== \"undefined\" // Should match node which includes crypto and window.crypto\n            ? Promise.resolve(crypto)\n            : await (\n                  await import(\"node:crypto\")\n              ).webcrypto;\n    }\n}\n\n/**\n * Crypto loader which loads native webcrypto depending on environment\n */\nexport const _crypto = CryptoLoader.load();\n\nexport async function encrypt<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaOaepParams\n        | AesCtrParams\n        | AesCbcParams\n        | AesGcmParams\n>(algorithm: U, key: T, data: BufferSource): Promise<ArrayBuffer> {\n    return await (await _crypto).subtle.encrypt(algorithm, key, data);\n}\n\nexport async function decrypt<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaOaepParams\n        | AesCtrParams\n        | AesCbcParams\n        | AesGcmParams\n>(algorithm: U, key: T, data: BufferSource): Promise<ArrayBuffer> {\n    return await (await _crypto).subtle.decrypt(algorithm, key, data);\n}\n\nexport async function sign<\n    T extends CryptoKey,\n    U extends AlgorithmIdentifier | RsaPssParams | EcdsaParams\n>(algorithm: U, key: T, data: BufferSource): Promise<ArrayBuffer> {\n    return await (await _crypto).subtle.sign(algorithm, key, data);\n}\n\nexport async function verify<\n    T extends CryptoKey,\n    U extends AlgorithmIdentifier | RsaPssParams | EcdsaParams\n>(\n    algorithm: U,\n    key: T,\n    signature: BufferSource,\n    data: BufferSource\n): Promise<boolean> {\n    return await (await _crypto).subtle.verify(algorithm, key, signature, data);\n}\n\nexport async function deriveKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | AesDerivedKeyParams\n        | HmacImportParams\n        | HkdfParams\n        | Pbkdf2Params\n>(\n    algorithm:\n        | AlgorithmIdentifier\n        | EcdhKeyDeriveParams\n        | HkdfParams\n        | Pbkdf2Params,\n    key: CryptoKey,\n    derivedKeyType: U,\n    extractable: boolean,\n    keyUsages: KeyUsage[]\n): Promise<T> {\n    return (await (\n        await _crypto\n    ).subtle.deriveKey(\n        algorithm,\n        key,\n        derivedKeyType,\n        extractable,\n        keyUsages\n    )) as T;\n}\n\nexport async function deriveBits<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | EcdhKeyDeriveParams\n        | HkdfParams\n        | Pbkdf2Params\n>(algorithm: U, baseKey: T, length: number): Promise<ArrayBuffer> {\n    if (length % 8 !== 0) {\n        throw new RangeError(\"Length must be a multiple of 8\");\n    }\n    return await (await _crypto).subtle.deriveBits(algorithm, baseKey, length);\n}\n\nexport async function wrapKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaOaepParams\n        | AesCtrParams\n        | AesCbcParams\n        | AesGcmParams\n>(\n    format: KeyFormat,\n    key: CryptoKey,\n    wrappingKey: T,\n    wrapAlgorithm: U\n): Promise<ArrayBuffer> {\n    return await (\n        await _crypto\n    ).subtle.wrapKey(format, key, wrappingKey, wrapAlgorithm);\n}\n\nexport async function unwrapKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaOaepParams\n        | AesCtrParams\n        | AesCbcParams\n        | AesGcmParams,\n    V extends\n        | AlgorithmIdentifier\n        | RsaHashedImportParams\n        | EcKeyImportParams\n        | HmacImportParams\n        | AesKeyAlgorithm\n>(\n    format: KeyFormat,\n    wrappedKey: BufferSource,\n    unwrappingKey: T,\n    unwrapAlgorithm: U,\n    unwrappedKeyAlgorithm: V,\n    extractable: boolean,\n    keyUsages: KeyUsage[]\n): Promise<CryptoKey> {\n    return await (\n        await _crypto\n    ).subtle.unwrapKey(\n        format,\n        wrappedKey,\n        unwrappingKey,\n        unwrapAlgorithm,\n        unwrappedKeyAlgorithm,\n        extractable,\n        keyUsages\n    );\n}\n\nexport async function exportKey<T extends CryptoKey>(\n    format: Extract<KeyFormat, \"jwk\">,\n    key: T\n): Promise<JsonWebKey>;\nexport async function exportKey<T extends CryptoKey>(\n    format: Exclude<KeyFormat, \"jwk\">,\n    key: T\n): Promise<ArrayBuffer>;\nexport async function exportKey<T extends CryptoKey>(\n    format: KeyFormat,\n    key: T\n): Promise<JsonWebKey | ArrayBuffer> {\n    if (format === \"jwk\") {\n        return await (await _crypto).subtle.exportKey(format, key);\n    }\n    return await (await _crypto).subtle.exportKey(format, key);\n}\n\nexport async function importKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaHashedImportParams\n        | EcKeyImportParams\n        | HmacImportParams\n        | AesKeyAlgorithm\n>(\n    format: Extract<KeyFormat, \"jwk\">,\n    key: JsonWebKey,\n    algorithm: U,\n    extractable: boolean,\n    keyUsages: KeyUsage[]\n): Promise<T>;\nexport async function importKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaHashedImportParams\n        | EcKeyImportParams\n        | HmacImportParams\n        | AesKeyAlgorithm\n>(\n    format: Exclude<KeyFormat, \"jwk\">,\n    key: BufferSource,\n    algorithm: U,\n    extractable: boolean,\n    keyUsages: KeyUsage[]\n): Promise<T>;\nexport async function importKey<\n    T extends CryptoKey,\n    U extends\n        | AlgorithmIdentifier\n        | RsaHashedImportParams\n        | EcKeyImportParams\n        | HmacImportParams\n        | AesKeyAlgorithm\n>(\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    algorithm: U,\n    extractable: boolean,\n    keyUsages: KeyUsage[]\n): Promise<T> {\n    if (format === \"jwk\") {\n        return (await (\n            await _crypto\n        ).subtle.importKey(\n            format,\n            key as JsonWebKey,\n            algorithm,\n            extractable,\n            keyUsages\n        )) as T;\n    }\n\n    return (await (\n        await _crypto\n    ).subtle.importKey(\n        format,\n        key as BufferSource,\n        algorithm,\n        extractable,\n        keyUsages\n    )) as T;\n}\n\nexport async function generateKey<\n    T extends CryptoKeyPair | CryptoKey,\n    U extends\n        | RsaHashedKeyGenParams\n        | EcKeyGenParams\n        | AesKeyGenParams\n        | HmacKeyGenParams\n        | Pbkdf2Params\n        | AlgorithmIdentifier\n>(algorithm: U, extractable: boolean, keyUsages: KeyUsage[]): Promise<T> {\n    return (await (\n        await _crypto\n    ).subtle.generateKey(algorithm, extractable, keyUsages)) as T;\n}\n\nexport async function digest<T extends ArrayBuffer>(\n    algorithm: SHA.Variants,\n    data: BufferSource\n): Promise<T> {\n    return (await (await _crypto).subtle.digest(algorithm, data)) as T;\n}\n", "/**\n * Shared code for EC\n * @module\n */\nimport { AesCryptoKeys } from \"../aes/shared.js\";\nimport { HmacCryptoKey } from \"../hmac/index.js\";\nimport { getKeyUsagePairsByAlg } from \"../key_usages.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport * as WebCrypto from \"../webcrypto.js\";\n\nexport interface EcdhPubCryptoKey extends CryptoKey {\n    _ecdhPubCryptoKeyBrand: any;\n}\nexport interface EcdhPrivCryptoKey extends CryptoKey {\n    _ecdhPrivCryptoKeyBrand: any;\n}\nexport interface EcdhCryptoKeyPair extends CryptoKeyPair {\n    _ecdhCryptoKeyPairBrand: any;\n    publicKey: EcdhPubCryptoKey;\n    privateKey: EcdhPrivCryptoKey;\n}\nexport interface EcdsaPubCryptoKey extends CryptoKey {\n    _ecdsaPubCryptoKeyBrand: any;\n}\nexport interface EcdsaPrivCryptoKey extends CryptoKey {\n    _ecdsaPrivCryptoKeyBrand: any;\n}\nexport interface EcdsaCryptoKeyPair extends CryptoKeyPair {\n    _ecdsaCryptoKeyPairBrand: any;\n    publicKey: EcdsaPubCryptoKey;\n    privateKey: EcdsaPrivCryptoKey;\n}\n\nexport interface EcdsaProxiedPubCryptoKey\n    extends proxy.ProxiedCryptoKey<EcdsaPubCryptoKey> {\n    verify: (\n        algorithm: Omit<params.EnforcedEcdsaParams, \"name\">,\n        signature: BufferSource,\n        data: BufferSource\n    ) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\nexport interface EcdsaProxiedPrivCryptoKey\n    extends proxy.ProxiedCryptoKey<EcdsaPrivCryptoKey> {\n    sign: (\n        algorithm: Omit<params.EnforcedEcdsaParams, \"name\">,\n        data: BufferSource\n    ) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface EcdsaProxiedCryptoKeyPair\n    extends proxy.ProxiedCryptoKeyPair<\n        EcdsaCryptoKeyPair,\n        EcdsaPrivCryptoKey,\n        EcdsaProxiedPrivCryptoKey,\n        EcdsaPubCryptoKey,\n        EcdsaProxiedPubCryptoKey\n    > {}\nexport interface EcdhProxiedPubCryptoKey\n    extends proxy.ProxiedCryptoKey<EcdhPubCryptoKey> {\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\nexport interface EcdhProxiedPrivCryptoKey\n    extends proxy.ProxiedCryptoKey<EcdhPrivCryptoKey> {\n    deriveKey: (\n        algorithm: Omit<params.EnforcedEcdhKeyDeriveParams, \"name\">,\n        derivedKeyType:\n            | params.EnforcedAesKeyGenParams\n            | params.EnforcedHmacKeyGenParams,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ) => Promise<HmacCryptoKey | AesCryptoKeys>;\n    deriveBits: (\n        algorithm: Omit<params.EnforcedEcdhKeyDeriveParams, \"name\">,\n        length: number\n    ) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface EcdhProxiedCryptoKeyPair\n    extends proxy.ProxiedCryptoKeyPair<\n        EcdhCryptoKeyPair,\n        EcdhPrivCryptoKey,\n        EcdhProxiedPrivCryptoKey,\n        EcdhPubCryptoKey,\n        EcdhProxiedPubCryptoKey\n    > {}\n\nexport type EcCryptoKeys =\n    | EcdhPubCryptoKey\n    | EcdhPrivCryptoKey\n    | EcdsaPubCryptoKey\n    | EcdsaPrivCryptoKey;\nexport type EcCryptoKeyPairs = EcdhCryptoKeyPair | EcdsaCryptoKeyPair;\n\nexport namespace Alg {\n    export enum Variant {\n        ECDSA = \"ECDSA\",\n        ECDH = \"ECDH\",\n    }\n    export type Variants = `${Variant}`;\n\n    export enum Curve {\n        P_256 = \"P-256\",\n        P_384 = \"P-384\",\n        P_521 = \"P-521\",\n    }\n\n    export type Curves = `${Curve}`;\n}\n\nexport namespace EcShared {\n    export async function generateKey<T extends EcCryptoKeyPairs>(\n        algorithm: params.EnforcedEcKeyGenParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<T> {\n        return await WebCrypto.generateKey<T, params.EnforcedEcKeyGenParams>(\n            algorithm,\n            extractable,\n            keyUsages ?? getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function importKey<T extends EcCryptoKeys>(\n        format: KeyFormat,\n        key: BufferSource | JsonWebKey,\n        algorithm: params.EnforcedEcKeyImportParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<T> {\n        return await WebCrypto.importKey<T, params.EnforcedEcKeyImportParams>(\n            format as any,\n            key as any,\n            algorithm,\n            extractable,\n            keyUsages ?? getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function exportKey(\n        format: KeyFormat,\n        key: EcCryptoKeys\n    ): Promise<JsonWebKey | ArrayBuffer> {\n        return await WebCrypto.exportKey(format as any, key);\n    }\n}\n", "/**\n * Code related to proxying CryptoKey and CryptoKeyPair\n * @module\n */\n\nexport interface ProxiedCryptoKey<T extends CryptoKey> {\n    self: T;\n    readonly algorithm: T[\"algorithm\"];\n    readonly extractable: T[\"extractable\"];\n    readonly type: T[\"type\"];\n    readonly usages: T[\"usages\"];\n}\n\nexport interface ProxiedCryptoKeyPair<\n    TKeyPair extends CryptoKeyPair,\n    TPrivKey extends CryptoKey,\n    TProxPrivKey extends ProxiedCryptoKey<TPrivKey>,\n    TPubKey extends CryptoKey,\n    TProxPubKey extends ProxiedCryptoKey<TPubKey>\n> {\n    self: TKeyPair;\n    privateKey: TProxPrivKey;\n    publicKey: TProxPubKey;\n}\nexport function proxifyKey<\n    TKey extends CryptoKey,\n    TProxKey extends ProxiedCryptoKey<TKey>\n>(handler: ProxyHandler<TKey>) {\n    return function _proxifyKey(key: TKey) {\n        return new Proxy<TKey, TProxKey>(key, handler);\n    };\n}\n\nexport interface ProxyKeyPairHandlers<\n    TPrivKey extends CryptoKey,\n    TPubKey extends CryptoKey\n> {\n    privHandler: ProxyHandler<TPrivKey>;\n    pubHandler: ProxyHandler<TPubKey>;\n}\n\nexport function proxifyKeyPair<\n    TKeyPair extends CryptoKeyPair,\n    TPrivKey extends CryptoKey,\n    TProxPrivKey extends ProxiedCryptoKey<TPrivKey>,\n    TPubKey extends CryptoKey,\n    TProxPubKey extends ProxiedCryptoKey<TPubKey>\n>({ privHandler, pubHandler }: ProxyKeyPairHandlers<TPrivKey, TPubKey>) {\n    return function _proxifyKeyPair(keyPair: TKeyPair) {\n        return new Proxy<\n            TKeyPair,\n            ProxiedCryptoKeyPair<\n                TKeyPair,\n                TPrivKey,\n                TProxPrivKey,\n                TPubKey,\n                TProxPubKey\n            >\n        >(keyPair, {\n            get(target: TKeyPair, prop: string) {\n                switch (prop) {\n                    case \"self\":\n                        return target;\n                    case \"privateKey\":\n                        return proxifyKey<TPrivKey, TProxPrivKey>(privHandler)(\n                            target.privateKey as TPrivKey\n                        );\n                    case \"publicKey\":\n                        return proxifyKey<TPubKey, TProxPubKey>(pubHandler)(\n                            target.publicKey as TPubKey\n                        );\n                }\n\n                return Reflect.get(target, prop);\n            },\n        });\n    };\n}\n", "/**\n * Shared code for SHA\n * @module\n */\n\nexport interface Sha1ArrayBuffer extends ArrayBuffer {\n    _sha1ArrayBufferBrand: any;\n}\nexport interface Sha256ArrayBuffer extends ArrayBuffer {\n    _sha256ArrayBufferBrand: any;\n}\nexport interface Sha384ArrayBuffer extends ArrayBuffer {\n    _sha384ArrayBufferBrand: any;\n}\nexport interface Sha512ArrayBuffer extends ArrayBuffer {\n    _sha512ArrayBufferBrand: any;\n}\n\nexport type ShaArrayBuffers =\n    | Sha1ArrayBuffer\n    | Sha256ArrayBuffer\n    | Sha384ArrayBuffer\n    | Sha512ArrayBuffer;\n\nexport namespace Alg {\n    export enum Variant {\n        SHA_1 = \"SHA-1\",\n        SHA_256 = \"SHA-256\",\n        SHA_384 = \"SHA-384\",\n        SHA_512 = \"SHA-512\",\n    }\n    export type Variants = `${Variant}`;\n    export type SecureVariants = `${Exclude<Variant, Variant.SHA_1>}`;\n}\n\nexport namespace ShaShared {\n    export const hexify = (digest: ShaArrayBuffers) =>\n        Array.from(new Uint8Array(digest))\n            .map((b) => b.toString(16).padStart(2, \"0\"))\n            .join(\"\");\n}\n", "/**\n * Code related to HMAC\n * @module\n */\nimport { getKeyUsagePairsByAlg } from \"../key_usages.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport { Alg as SHA } from \"../sha/shared.js\";\nimport * as WebCrypto from \"../webcrypto.js\";\n\nexport interface HmacCryptoKey extends CryptoKey {\n    _hmacKeyBrand: any;\n}\nexport interface HmacProxiedCryptoKey\n    extends proxy.ProxiedCryptoKey<HmacCryptoKey> {\n    sign: (data: BufferSource) => Promise<ArrayBuffer>;\n    verify: (signature: BufferSource, data: BufferSource) => Promise<boolean>;\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport const handler: ProxyHandler<HmacCryptoKey> = {\n    get(target: HmacCryptoKey, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n            case \"sign\":\n                return (data: BufferSource) => sign(target, data);\n            case \"verify\":\n                return (signature: BufferSource, data: BufferSource) =>\n                    verify(target, signature, data);\n            case \"exportKey\":\n                return (format: KeyFormat) => exportKey(format, target);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\nexport namespace Alg {\n    export enum Code {\n        HMAC = \"HMAC\",\n    }\n    export type Codes = `${Code}`;\n}\n\n/**\n * Generate a new HMAC key\n * @example\n * ```ts\n * const key = await HMAC.generateKey();\n * ```\n */\nexport const generateKey = async (\n    algorithm: Omit<params.EnforcedHmacKeyGenParams, \"name\"> = {\n        hash: SHA.Variant.SHA_512,\n    },\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<HmacProxiedCryptoKey> => {\n    const key = await WebCrypto.generateKey<\n        HmacCryptoKey,\n        params.EnforcedHmacKeyGenParams\n    >(\n        {\n            ...algorithm,\n            name: Alg.Code.HMAC,\n        },\n        extractable,\n        keyUsages ?? getKeyUsagePairsByAlg(Alg.Code.HMAC)\n    );\n    return proxy.proxifyKey<HmacCryptoKey, HmacProxiedCryptoKey>(handler)(key);\n};\n\n/**\n * Import an HMAC key from the specified format\n * @example\n * ```ts\n * const key = await HMAC.importKey(\"jwk\", jwk, {hash: \"SHA-512\"});\n * ```\n */\nexport const importKey = async (\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    algorithm: Omit<params.EnforcedHmacImportParams, \"name\">,\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<HmacProxiedCryptoKey> => {\n    const importedKey = await WebCrypto.importKey<\n        HmacCryptoKey,\n        params.EnforcedHmacImportParams\n    >(\n        format as any,\n        key as any,\n        { ...algorithm, name: Alg.Code.HMAC },\n        extractable,\n        keyUsages ?? getKeyUsagePairsByAlg(Alg.Code.HMAC)\n    );\n\n    return proxy.proxifyKey<HmacCryptoKey, HmacProxiedCryptoKey>(handler)(\n        importedKey\n    );\n};\n\n/**\n * Export an HMAC key into the specified format\n * @example\n * ```ts\n * const jwk = await HMAC.exportKey(\"jwk\", key.self);\n * ```\n * @example\n * ```ts\n * const jwk = await key.exportKey(\"jwk\");\n * ```\n */\nexport async function exportKey(\n    format: KeyFormat,\n    key: HmacCryptoKey\n): Promise<JsonWebKey | ArrayBuffer> {\n    return await WebCrypto.exportKey<HmacCryptoKey>(format as any, key);\n}\n\n/**\n * Sign a given payload\n * @example\n * ```ts\n * const message = new TextEncoder().encode(\"a message\");\n * const signature = await HMAC.sign(key.self, message);\n * ```\n * ```ts\n * const message = new TextEncoder().encode(\"a message\");\n * const signature = await key.sign(message);\n * ```\n */\nexport async function sign(\n    key: HmacCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await WebCrypto.sign<HmacCryptoKey, params.HmacKeyAlgorithm>(\n        {\n            name: Alg.Code.HMAC,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Verify a given signature\n * @example\n * ```ts\n * const isVerified = await HMAC.verify(key, signature, message);\n * ```\n * @example\n * ```ts\n * const isVerified = await key.verify(signature, message);\n * ```\n */\nexport async function verify(\n    key: HmacCryptoKey,\n    signature: BufferSource,\n    data: BufferSource\n): Promise<boolean> {\n    return await WebCrypto.verify<HmacCryptoKey, params.HmacKeyAlgorithm>(\n        {\n            name: Alg.Code.HMAC,\n        },\n        key,\n        signature,\n        data\n    );\n}\n", "/**\n * Shared code for KDF\n * @module\n */\nimport type { AesCryptoKeys } from \"../aes/index.js\";\nimport { AesProxiedCryptoKeys } from \"../aes/shared.js\";\nimport { HmacCryptoKey, HmacProxiedCryptoKey } from \"../hmac/index.js\";\nimport { DeriveKeyUsagePair, getKeyUsagePairsByAlg } from \"../key_usages.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport * as WebCrypto from \"../webcrypto.js\";\n\nexport interface Pbkdf2KeyMaterial extends CryptoKey {\n    _pbkdf2KeyMaterialBrand: any;\n}\nexport interface HkdfKeyMaterial extends CryptoKey {\n    _kkdfKeyMaterialBrand: any;\n}\n\nexport namespace Alg {\n    export enum Variant {\n        PBKDF2 = \"PBKDF2\",\n        HKDF = \"HKDF\",\n    }\n    export type Variants = `${Variant}`;\n}\n\nexport namespace KdfShared {\n    export async function generateKeyMaterial<K extends CryptoKey>(\n        format: KeyFormat,\n        key: BufferSource,\n        algorithm: Alg.Variants,\n        extractable: boolean = false\n    ): Promise<K> {\n        return await WebCrypto.importKey(\n            format as any,\n            key,\n            algorithm,\n            extractable,\n            DeriveKeyUsagePair\n        );\n    }\n\n    export async function deriveKey(\n        algorithm: params.EnforcedPbkdf2Params | params.EnforcedHkdfParams,\n        baseKey: Pbkdf2KeyMaterial | HkdfKeyMaterial,\n        derivedKeyType:\n            | params.EnforcedAesKeyGenParams\n            | params.EnforcedHmacKeyGenParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<AesCryptoKeys | HmacCryptoKey> {\n        return await WebCrypto.deriveKey<\n            AesCryptoKeys | HmacCryptoKey,\n            params.EnforcedAesKeyGenParams | params.EnforcedHmacKeyGenParams\n        >(\n            algorithm,\n            baseKey,\n            derivedKeyType,\n            extractable,\n            keyUsages ?? getKeyUsagePairsByAlg(derivedKeyType.name)\n        );\n    }\n\n    export async function deriveBits(\n        algorithm: params.EnforcedPbkdf2Params | params.EnforcedHkdfParams,\n        baseKey: Pbkdf2KeyMaterial | HkdfKeyMaterial,\n        length: number\n    ): Promise<ArrayBuffer> {\n        return await WebCrypto.deriveBits(algorithm, baseKey, length);\n    }\n}\n\nexport interface HkdfProxiedKeyMaterial\n    extends proxy.ProxiedCryptoKey<HkdfKeyMaterial> {\n    deriveKey(\n        algorithm: Omit<params.EnforcedHkdfParams, \"name\">,\n        derivedKeyType:\n            | params.EnforcedAesKeyGenParams\n            | params.EnforcedHmacKeyGenParams,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<AesProxiedCryptoKeys | HmacProxiedCryptoKey>;\n\n    deriveBits(\n        algorithm: Omit<params.EnforcedHkdfParams, \"name\">,\n        length: number\n    ): Promise<ArrayBuffer>;\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface Pbkdf2ProxiedKeyMaterial\n    extends proxy.ProxiedCryptoKey<Pbkdf2KeyMaterial> {\n    deriveKey(\n        algorithm: Omit<params.EnforcedPbkdf2Params, \"name\" | \"iterations\">,\n        derivedKeyType:\n            | params.EnforcedAesKeyGenParams\n            | params.EnforcedHmacKeyGenParams,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<AesProxiedCryptoKeys | HmacProxiedCryptoKey>;\n    deriveBits(\n        algorithm: Omit<params.EnforcedPbkdf2Params, \"name\" | \"iterations\">,\n        length: number\n    ): Promise<ArrayBuffer>;\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n", "/**\n * Shared code for RSA\n * @module\n */\n\nimport { getKeyUsagePairsByAlg, KeyUsagePairs } from \"../key_usages.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport * as WebCrypto from \"../webcrypto.js\";\n\nexport interface RsaOaepPubCryptoKey extends CryptoKey {\n    _rsaOaepPubCryptoKeyBrand: any;\n}\nexport interface RsaOaepPrivCryptoKey extends CryptoKey {\n    _rsaOaepPrivCryptoKeyBrand: any;\n}\nexport interface RsaPssPubCryptoKey extends CryptoKey {\n    _rsaPssPubCryptoKeyBrand: any;\n}\nexport interface RsaPssPrivCryptoKey extends CryptoKey {\n    _rsaPssPrivCryptoKeyBrand: any;\n}\nexport interface RsassaPkcs1V15PubCryptoKey extends CryptoKey {\n    _rsassaPkcs1V15PubCryptoKeyBrand: any;\n}\nexport interface RsassaPkcs1V15PrivCryptoKey extends CryptoKey {\n    _rsassaPkcs1V15PrivCryptoKeyBrand: any;\n}\n\nexport type RsaCryptoKeys =\n    | RsaOaepPubCryptoKey\n    | RsaOaepPrivCryptoKey\n    | RsaPssPubCryptoKey\n    | RsaPssPrivCryptoKey\n    | RsassaPkcs1V15PubCryptoKey\n    | RsassaPkcs1V15PrivCryptoKey;\n\nexport interface RsaOaepCryptoKeyPair extends CryptoKeyPair {\n    _rsaOaepCryptoKeyPairBrand: any;\n    publicKey: RsaOaepPubCryptoKey;\n\n    privateKey: RsaOaepPrivCryptoKey;\n}\nexport interface RsaPssCryptoKeyPair extends CryptoKeyPair {\n    _rsaPssCryptoKeyPairBrand: any;\n    publicKey: RsaPssPubCryptoKey;\n\n    privateKey: RsaPssPrivCryptoKey;\n}\nexport interface RsassaPkcs1V15CryptoKeyPair extends CryptoKeyPair {\n    _rsassaPkcs1V15CryptoKeyBrand: any;\n    publicKey: RsassaPkcs1V15PubCryptoKey;\n\n    privateKey: RsassaPkcs1V15PrivCryptoKey;\n}\nexport type RsaCryptoKeyPairs =\n    | RsaOaepCryptoKeyPair\n    | RsaPssCryptoKeyPair\n    | RsassaPkcs1V15CryptoKeyPair;\n\nexport namespace Alg {\n    export enum Variant {\n        RSA_OAEP = \"RSA-OAEP\",\n        RSA_PSS = \"RSA-PSS\",\n        RSASSA_PKCS1_v1_5 = \"RSASSA-PKCS1-v1_5\",\n    }\n    export type Variants = `${Variant}`;\n}\n\nexport namespace RsaShared {\n    export async function generateKey(\n        algorithm: params.EnforcedRsaHashedKeyGenParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<RsaCryptoKeys | RsaCryptoKeyPairs> {\n        return await WebCrypto.generateKey<\n            RsaCryptoKeys | RsaCryptoKeyPairs,\n            params.EnforcedRsaHashedKeyGenParams\n        >(\n            algorithm,\n            extractable,\n            keyUsages ?? getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function importKey<T extends RsaCryptoKeys>(\n        format: KeyFormat,\n        key: BufferSource | JsonWebKey,\n        algorithm: params.EnforcedRsaHashedImportParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<T> {\n        return await WebCrypto.importKey<\n            T,\n            params.EnforcedRsaHashedImportParams\n        >(\n            format as any,\n            key as any,\n            algorithm,\n            extractable,\n            keyUsages ?? getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function exportKey<T extends RsaCryptoKeys>(\n        format: KeyFormat,\n        key: T\n    ): Promise<JsonWebKey | ArrayBuffer> {\n        return await WebCrypto.exportKey(format as any, key);\n    }\n\n    export async function sign(\n        algorithm:\n            | params.EnforcedRsaPssParams\n            | params.EnforcedRsassaPkcs1v15Params,\n        key: RsaPssPrivCryptoKey | RsassaPkcs1V15PrivCryptoKey,\n        data: BufferSource\n    ): Promise<ArrayBuffer> {\n        return await WebCrypto.sign(algorithm, key, data);\n    }\n\n    export async function verify(\n        algorithm:\n            | params.EnforcedRsaPssParams\n            | params.EnforcedRsassaPkcs1v15Params,\n        key: RsaPssPubCryptoKey | RsassaPkcs1V15PubCryptoKey,\n        signature: BufferSource,\n        data: BufferSource\n    ): Promise<boolean> {\n        return await WebCrypto.verify(algorithm, key, signature, data);\n    }\n}\n\nexport interface RsaOaepProxiedPubCryptoKey\n    extends proxy.ProxiedCryptoKey<RsaOaepPubCryptoKey> {\n    encrypt: (\n        algorithm: Omit<params.EnforcedRsaOaepParams, \"name\">,\n        data: BufferSource\n    ) => Promise<ArrayBuffer>;\n    wrapKey: (\n        format: KeyFormat,\n        key: CryptoKey,\n        wrapAlgorithm?: Omit<params.EnforcedRsaOaepParams, \"name\">\n    ) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\nexport interface RsaOaepProxiedPrivCryptoKey\n    extends proxy.ProxiedCryptoKey<RsaOaepPrivCryptoKey> {\n    decrypt: (\n        algorithm: Omit<params.EnforcedRsaOaepParams, \"name\">,\n        data: BufferSource\n    ) => Promise<ArrayBuffer>;\n\n    unwrapKey: (\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        // unwrappingKey: RsaOaepPrivCryptoKey,\n        unwrappingKeyAlgorithm: Omit<params.EnforcedRsaOaepParams, \"name\">,\n        extractable?: boolean,\n        keyUsages?: KeyUsagePairs\n    ) => Promise<CryptoKey>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface RsaOaepProxiedCryptoKeyPair\n    extends proxy.ProxiedCryptoKeyPair<\n        RsaOaepCryptoKeyPair,\n        RsaOaepPrivCryptoKey,\n        RsaOaepProxiedPrivCryptoKey,\n        RsaOaepPubCryptoKey,\n        RsaOaepProxiedPubCryptoKey\n    > {}\n\nexport interface RsaPssProxiedPubCryptoKey\n    extends proxy.ProxiedCryptoKey<RsaPssPubCryptoKey> {\n    verify: (\n        saltLength: number,\n        signature: BufferSource,\n        data: BufferSource\n    ) => Promise<boolean>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\nexport interface RsaPssProxiedPrivCryptoKey\n    extends proxy.ProxiedCryptoKey<RsaPssPrivCryptoKey> {\n    sign: (saltLength: number, data: BufferSource) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface RsaPssProxiedCryptoKeyPair\n    extends proxy.ProxiedCryptoKeyPair<\n        RsaPssCryptoKeyPair,\n        RsaPssPrivCryptoKey,\n        RsaPssProxiedPrivCryptoKey,\n        RsaPssPubCryptoKey,\n        RsaPssProxiedPubCryptoKey\n    > {}\n\nexport interface RsassaPkcs1V15ProxiedPubCryptoKey\n    extends proxy.ProxiedCryptoKey<RsassaPkcs1V15PubCryptoKey> {\n    verify: (signature: BufferSource, data: BufferSource) => Promise<boolean>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\nexport interface RsassaPkcs1V15ProxiedPrivCryptoKey\n    extends proxy.ProxiedCryptoKey<RsassaPkcs1V15PrivCryptoKey> {\n    sign: (data: BufferSource) => Promise<ArrayBuffer>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface RsassaPkcs1V15ProxiedCryptoKeyPair\n    extends proxy.ProxiedCryptoKeyPair<\n        RsassaPkcs1V15CryptoKeyPair,\n        RsassaPkcs1V15PrivCryptoKey,\n        RsassaPkcs1V15ProxiedPrivCryptoKey,\n        RsassaPkcs1V15PubCryptoKey,\n        RsassaPkcs1V15ProxiedPubCryptoKey\n    > {}\n", "/**\n * Key usages and allowed formats\n * @module\n */\n\nimport { Alg as AES } from \"./aes/shared.js\";\nimport { Alg as EC } from \"./ec/shared.js\";\nimport { Alg as Authentication } from \"./hmac/index.js\";\nimport { Alg as KDF } from \"./kdf/shared.js\";\nimport { Alg as RSA } from \"./rsa/shared.js\";\n\nexport enum KeyFormats {\n    raw = \"raw\",\n    pkcs8 = \"pkcs8\",\n    spki = \"spki\",\n    jwk = \"jwk\",\n}\n\nexport enum KeyUsages {\n    encrypt = \"encrypt\",\n    decrypt = \"decrypt\",\n    sign = \"sign\",\n    verify = \"verify\",\n    deriveKey = \"deriveKey\",\n    deriveBits = \"deriveBits\",\n    wrapKey = \"wrapKey\",\n    unwrapKey = \"unwrapKey\",\n}\n\nexport type KeyUsagePair = [KeyUsage, KeyUsage];\n\nexport type EncryptionKeyUsagePair = [KeyUsages.encrypt, KeyUsages.decrypt];\nexport const EncryptionKeyUsagePair: KeyUsagePair = [\n    KeyUsages.encrypt,\n    KeyUsages.decrypt,\n];\nexport type SigningKeyUsagePair = [KeyUsages.sign, KeyUsages.verify];\nexport const SigningKeyUsagePair: KeyUsagePair = [\n    KeyUsages.sign,\n    KeyUsages.verify,\n];\nexport type WrappingKeyUsagePair = [KeyUsages.wrapKey, KeyUsages.unwrapKey];\nexport const WrappingKeyUsagePair: KeyUsagePair = [\n    KeyUsages.wrapKey,\n    KeyUsages.unwrapKey,\n];\nexport type DeriveKeyUsagePair = [KeyUsages.deriveKey, KeyUsages.deriveBits];\nexport const DeriveKeyUsagePair: KeyUsagePair = [\n    KeyUsages.deriveKey,\n    KeyUsages.deriveBits,\n];\n\nexport type KeyUsagePairs =\n    | EncryptionKeyUsagePair\n    | SigningKeyUsagePair\n    | WrappingKeyUsagePair\n    | DeriveKeyUsagePair;\n\n/**\n * Given a algorithm, return the _most likely_ key usage pair.\n */\nexport function getKeyUsagePairsByAlg(alg: string): KeyUsagePair {\n    switch (alg) {\n        case AES.Mode.AES_CBC:\n        case AES.Mode.AES_CTR:\n        case AES.Mode.AES_GCM:\n        case RSA.Variant.RSA_OAEP:\n            return EncryptionKeyUsagePair;\n\n        case Authentication.Code.HMAC:\n        case EC.Variant.ECDSA:\n        case RSA.Variant.RSA_PSS:\n        case RSA.Variant.RSASSA_PKCS1_v1_5:\n            return SigningKeyUsagePair;\n\n        case EC.Variant.ECDH:\n        case KDF.Variant.HKDF:\n        case KDF.Variant.PBKDF2:\n            return DeriveKeyUsagePair;\n\n        case AES.Mode.AES_KW:\n            return WrappingKeyUsagePair;\n        default:\n            throw new Error(`Invalid alg ${alg}`);\n    }\n}\n", "/**\n * Shared code for AES\n * @module\n */\n\nimport * as usages from \"../key_usages.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport * as WebCrypto from \"../webcrypto.js\";\n\nexport interface AesGcmCryptoKey extends CryptoKey {\n    _aesGcmKeyBrand: any;\n}\n\nexport interface AesKwCryptoKey extends CryptoKey {\n    _aesKwKeyBrand: any;\n}\n\nexport interface AesCtrCryptoKey extends CryptoKey {\n    _aesCtrKeyBrand: any;\n}\n\nexport interface AesCbcCryptoKey extends CryptoKey {\n    _aesCbcKeyBrand: any;\n}\n\nexport type AesCryptoKeys =\n    | AesCbcCryptoKey\n    | AesKwCryptoKey\n    | AesGcmCryptoKey\n    | AesCtrCryptoKey;\n\nexport namespace Alg {\n    export enum Mode {\n        AES_CBC = \"AES-CBC\",\n        AES_CTR = \"AES-CTR\",\n        AES_GCM = \"AES-GCM\",\n        AES_KW = \"AES-KW\",\n    }\n\n    export type Modes = `${Mode}`;\n}\n\nexport namespace AesShared {\n    export async function generateKey<T extends CryptoKey>(\n        algorithm: params.EnforcedAesKeyGenParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<T> {\n        return await WebCrypto.generateKey<T, params.EnforcedAesKeyGenParams>(\n            algorithm,\n            extractable,\n            keyUsages ?? usages.getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function importKey<T extends CryptoKey>(\n        format: KeyFormat,\n        key: BufferSource | JsonWebKey,\n        algorithm: params.EnforcedAesKeyAlgorithms,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<T> {\n        return await WebCrypto.importKey<T, params.EnforcedAesKeyAlgorithms>(\n            format as any,\n            key as any,\n            algorithm,\n            extractable,\n            keyUsages ?? usages.getKeyUsagePairsByAlg(algorithm.name)\n        );\n    }\n\n    export async function exportKey<T extends CryptoKey>(\n        format: KeyFormat,\n        key: T\n    ): Promise<JsonWebKey | ArrayBuffer> {\n        return await WebCrypto.exportKey(format as any, key);\n    }\n\n    export async function encrypt<T extends CryptoKey>(\n        algorithm: Exclude<\n            params.EnforcedAesParams,\n            params.EnforcedAesKwParams\n        >,\n        key: T,\n        data: BufferSource\n    ): Promise<ArrayBuffer> {\n        return await WebCrypto.encrypt(algorithm, key, data);\n    }\n\n    export async function decrypt<T extends CryptoKey>(\n        algorithm: Exclude<\n            params.EnforcedAesParams,\n            params.EnforcedAesKwParams\n        >,\n        key: T,\n        data: BufferSource\n    ): Promise<ArrayBuffer> {\n        return await WebCrypto.decrypt(algorithm, key, data);\n    }\n\n    export async function wrapKey<T extends CryptoKey>(\n        format: KeyFormat,\n        key: CryptoKey,\n        wrappingkey: T,\n        wrapAlgorithm: params.EnforcedAesParams\n    ): Promise<ArrayBuffer> {\n        return await WebCrypto.wrapKey(\n            format as any,\n            key,\n            wrappingkey,\n            wrapAlgorithm\n        );\n    }\n    export async function unwrapKey<T extends CryptoKey>(\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        unwrappingKey: T,\n        unwrappingKeyAlgorithm: params.EnforcedAesParams,\n        extractable: boolean = true,\n        keyUsages?: KeyUsage[]\n    ): Promise<CryptoKey> {\n        return await WebCrypto.unwrapKey(\n            format as any,\n            wrappedKey,\n            unwrappingKey,\n            unwrappingKeyAlgorithm,\n            wrappedKeyAlgorithm,\n            extractable,\n            keyUsages ?? usages.getKeyUsagePairsByAlg(wrappedKeyAlgorithm.name)\n        );\n    }\n}\n\nexport interface AesCbcProxiedCryptoKey\n    extends proxy.ProxiedCryptoKey<AesCbcCryptoKey> {\n    encrypt(\n        algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    decrypt(\n        algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    wrapKey(\n        format: KeyFormat,\n        key: CryptoKey,\n        wrapAlgorithm: Omit<params.EnforcedAesCbcParams, \"name\">\n    ): Promise<ArrayBuffer>;\n\n    unwrapKey(\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        unwrappingKeyAlgorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<CryptoKey>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface AesCtrProxiedCryptoKey\n    extends proxy.ProxiedCryptoKey<AesCtrCryptoKey> {\n    encrypt(\n        algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    decrypt(\n        algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    wrapKey(\n        format: KeyFormat,\n        key: CryptoKey,\n        wrapAlgorithm: Omit<params.EnforcedAesCtrParams, \"name\">\n    ): Promise<ArrayBuffer>;\n\n    unwrapKey(\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        unwrappingKeyAlgorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<CryptoKey>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface AesGcmProxiedCryptoKey\n    extends proxy.ProxiedCryptoKey<AesGcmCryptoKey> {\n    encrypt(\n        algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    decrypt(\n        algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n        data: BufferSource\n    ): Promise<ArrayBuffer>;\n\n    wrapKey(\n        format: KeyFormat,\n        key: CryptoKey,\n        wrapAlgorithm: Omit<params.EnforcedAesGcmParams, \"name\">\n    ): Promise<ArrayBuffer>;\n\n    unwrapKey(\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        unwrappingKeyAlgorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<CryptoKey>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport interface AesKwProxiedCryptoKey\n    extends proxy.ProxiedCryptoKey<AesKwCryptoKey> {\n    wrapKey(format: KeyFormat, key: CryptoKey): Promise<ArrayBuffer>;\n\n    unwrapKey(\n        format: KeyFormat,\n        wrappedKey: BufferSource,\n        wrappedKeyAlgorithm: params.EnforcedImportParams,\n        extractable?: boolean,\n        keyUsages?: KeyUsage[]\n    ): Promise<CryptoKey>;\n\n    exportKey: (format: KeyFormat) => Promise<JsonWebKey | ArrayBuffer>;\n}\n\nexport type AesProxiedCryptoKeys =\n    | AesCbcProxiedCryptoKey\n    | AesKwProxiedCryptoKey\n    | AesGcmProxiedCryptoKey\n    | AesCtrProxiedCryptoKey;\n", "/**\n * Code related to AES_CBC mode\n * @module\n */\n\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport {\n    AesCbcCryptoKey,\n    AesCbcProxiedCryptoKey,\n    AesShared,\n    Alg,\n} from \"./shared.js\";\n\nexport const handler: ProxyHandler<AesCbcCryptoKey> = {\n    get(target: AesCbcCryptoKey, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n\n            case \"encrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n                    data: BufferSource\n                ) => encrypt(algorithm, target, data);\n\n            case \"decrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n                    data: BufferSource\n                ) => decrypt(algorithm, target, data);\n\n            case \"wrapKey\":\n                return (\n                    format: KeyFormat,\n                    key: CryptoKey,\n                    wrapAlgorithm: Omit<params.EnforcedAesCbcParams, \"name\">\n                ) => wrapKey(format, key, target, wrapAlgorithm);\n\n            case \"unwrapKey\":\n                return (\n                    format: KeyFormat,\n                    wrappedKey: BufferSource,\n                    wrappedKeyAlgorithm: params.EnforcedImportParams,\n                    unwrappingKeyAlgorithm: Omit<\n                        params.EnforcedAesCbcParams,\n                        \"name\"\n                    >,\n                    extractable?: boolean,\n                    keyUsages?: KeyUsage[]\n                ) =>\n                    unwrapKey(\n                        format,\n                        wrappedKey,\n                        wrappedKeyAlgorithm,\n                        target,\n                        unwrappingKeyAlgorithm,\n                        extractable,\n                        keyUsages\n                    );\n\n            case \"exportKey\":\n                return (format: KeyFormat) => exportKey(format, target);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\n/**\n * Generate a new AES_CBC key\n * @example\n * ```ts\n * const key = await AES_CBC.generateKey();\n * ```\n */\nexport async function generateKey(\n    algorithm: Omit<params.EnforcedAesKeyGenParams, \"name\"> = {\n        length: 256,\n    },\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<AesCbcProxiedCryptoKey> {\n    const key = await AesShared.generateKey<AesCbcCryptoKey>(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CBC,\n        },\n        extractable,\n        keyUsages\n    );\n    return proxy.proxifyKey<AesCbcCryptoKey, AesCbcProxiedCryptoKey>(handler)(\n        key\n    );\n}\n\n/**\n * Import an AES_CBC key\n * @example\n * ```ts\n * const jwk = await AES_CBC.importKey(\"jwk\", jwk, {\n *     length: 256,\n * });\n * ```\n */\nexport async function importKey(\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    algorithm: Omit<params.AesCbcKeyAlgorithm, \"name\">,\n    extractable?: boolean,\n    keyUsages?: KeyUsage[]\n): Promise<AesCbcProxiedCryptoKey> {\n    const importedKey = (await AesShared.importKey(\n        format as any,\n        key as any,\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CBC,\n        },\n        extractable,\n        keyUsages\n    )) as AesCbcCryptoKey;\n    return proxy.proxifyKey<AesCbcCryptoKey, AesCbcProxiedCryptoKey>(handler)(\n        importedKey\n    );\n}\n\n/**\n * Export an AES_CBC key\n * @example\n * ```ts\n * const key = await AES_CBC.generateKey();\n * const jwk = await AES_CBC.exportKey(\"jwk\", key.self);\n * ```\n * @example\n * ```ts\n * const key = await AES_CBC.generateKey();\n * const jwk = await key.exportKey(\"jwk\");\n * ```\n */\nexport const exportKey = async (format: KeyFormat, key: AesCbcCryptoKey) =>\n    AesShared.exportKey(format, key);\n\n/**\n * Encrypt payload with an AES_CBC key\n * @example\n * ```ts\n * const key = await AES_CBC.generateKey();\n * const iv = await IV.generate();\n * const ciphertextBytes = await AES_CBC.encrypt(\n *     { iv },\n *    key.self,\n *    new TextEncoder().encode('message')\n * );\n * ```\n * @example\n * ```ts\n * const key = await AES_CBC.generateKey();\n * const iv = await IV.generate();\n * const ciphertextBytes = await key.encrypt(\n *     { iv },\n *    new TextEncoder().encode('message')\n * );\n * ```\n */\nexport async function encrypt(\n    algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n    key: AesCbcCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.encrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CBC,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Decrypt data with an AES_CBC key\n * @example\n * ```ts\n * const plaintextBytes = await AES_CBC.decrypt(\n *    { iv },\n *    key.self,\n *    ciphertextBytes\n * );\n * ```\n * @example\n * ```ts\n * const plaintextBytes = await key.decrypt(\n *    { iv },\n *    ciphertextBytes\n * );\n * ```\n */\nexport async function decrypt(\n    algorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n    key: AesCbcCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.decrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CBC,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Wrap another key with an AES_CBC key\n * @example\n * ```ts\n * const kek = await AES_CBC.generateKey({ length: 256 }, true, [\n *    \"wrapKey\",\n *    \"unwrapKey\",\n * ]);\n * const dek: AesCbcCryptoKey = await AES_CBC.generateKey({\n *    length: 256,\n * });\n * const iv = await IV.generate();\n * const wrappedKey = await AES_CBC.wrapKey(\"raw\", dek, kek, {\n *     iv,\n * });\n * ```\n * ```ts\n * const kek = await AES_CBC.generateKey({ length: 256 }, true, [\n *    \"wrapKey\",\n *    \"unwrapKey\",\n * ]);\n * const dek: AesCbcCryptoKey = await AES_CBC.generateKey({\n *    length: 256,\n * });\n * const iv = await IV.generate();\n * const wrappedKey = await kek.wrapKey(\"raw\", dek.self, {\n *     iv,\n * });\n * ```\n */\nexport async function wrapKey(\n    format: KeyFormat,\n    key: CryptoKey,\n    wrappingkey: AesCbcCryptoKey,\n    wrapAlgorithm: Omit<params.EnforcedAesCbcParams, \"name\">\n): Promise<ArrayBuffer> {\n    return await AesShared.wrapKey(format as any, key, wrappingkey, {\n        ...wrapAlgorithm,\n        name: Alg.Mode.AES_CBC,\n    });\n}\n\n/**\n * Unwrap a wrapped key using the key encryption key\n * @example\n * ```ts\n * const wrappedKey = await AES_CBC.wrapKey(\"raw\", dek.self, kek.self, {\n *     iv,\n * });\n * const unwrappedKey = await AES_CBC.unwrapKey(\n *    \"raw\",\n *    wrappedKey,\n *    { name: Alg.Mode.AES_CBC },\n *    kek.self,\n *    { iv }\n * );\n * ```\n * @example\n * ```ts\n * const wrappedKey = await AES_CBC.wrapKey(\"raw\", dek.self, kek.self, {\n *     iv,\n * });\n * const unwrappedKey = await kek.unwrapKey(\n *    \"raw\",\n *    wrappedKey,\n *    { name: Alg.Mode.AES_CBC },\n *    { iv }\n * );\n * ```\n */\nexport async function unwrapKey(\n    format: KeyFormat,\n    wrappedKey: BufferSource,\n    wrappedKeyAlgorithm: params.EnforcedImportParams,\n    unwrappingKey: AesCbcCryptoKey,\n    unwrappingKeyAlgorithm: Omit<params.EnforcedAesCbcParams, \"name\">,\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<CryptoKey> {\n    return await AesShared.unwrapKey(\n        format,\n        wrappedKey,\n        wrappedKeyAlgorithm,\n        unwrappingKey,\n        {\n            ...unwrappingKeyAlgorithm,\n            name: Alg.Mode.AES_CBC,\n        },\n        extractable,\n        keyUsages\n    );\n}\n", "/**\n * Cryptographically strong random values.\n * @module\n */\n\nimport * as WebCrypto from \"./webcrypto.js\";\n\n/**\n * Generate random values\n * @example\n * ```ts\n * const values = await Random.getValues(16);\n * ```\n */\nexport async function getValues(length: number): Promise<Uint8Array> {\n    return await (\n        await WebCrypto._crypto\n    ).getRandomValues(new Uint8Array(length));\n}\n\n/**\n * Initialization Vectors\n */\nexport namespace IV {\n    /**\n     * Generate an initialization vector. Defaults to 16 bytes.\n     * @example\n     * ```ts\n     * const iv = await Random.IV.generate();\n     * ```\n     */\n    export async function generate(length: number = 16): Promise<Uint8Array> {\n        return await getValues(length);\n    }\n}\n\n/**\n * Salts\n */\nexport namespace Salt {\n    /**\n     * Generate a salt. Defaults to 16 bytes.\n     * @example\n     * ```ts\n     * const salt = await Random.Salt.generate();\n     * ```\n     */\n    export async function generate(length: number = 16): Promise<Uint8Array> {\n        return await getValues(length);\n    }\n}\n\n/**\n * UUID\n */\nexport namespace UUID {\n    /**\n     * Generate a UUID.\n     * @example\n     * ```ts\n     * const uuid = await Random.UUID.generate();\n     * ```\n     */\n    export async function generate(): Promise<string> {\n        return await (await WebCrypto._crypto).randomUUID();\n    }\n}\n", "/**\n * Code related to AES_CTR mode\n * @module\n */\n\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport { getValues } from \"../random.js\";\nimport {\n    AesCtrCryptoKey,\n    AesCtrProxiedCryptoKey,\n    AesShared,\n    Alg,\n} from \"./shared.js\";\n\nexport const handler: ProxyHandler<AesCtrCryptoKey> = {\n    get(target: AesCtrCryptoKey, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n\n            case \"encrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n                    data: BufferSource\n                ) => encrypt(algorithm, target, data);\n\n            case \"decrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n                    data: BufferSource\n                ) => decrypt(algorithm, target, data);\n\n            case \"wrapKey\":\n                return (\n                    format: KeyFormat,\n                    key: CryptoKey,\n                    wrapAlgorithm: Omit<params.EnforcedAesCtrParams, \"name\">\n                ) => wrapKey(format, key, target, wrapAlgorithm);\n\n            case \"unwrapKey\":\n                return (\n                    format: KeyFormat,\n                    wrappedKey: BufferSource,\n                    wrappedKeyAlgorithm: params.EnforcedImportParams,\n                    unwrappingKeyAlgorithm: Omit<\n                        params.EnforcedAesCtrParams,\n                        \"name\"\n                    >,\n                    extractable?: boolean,\n                    keyUsages?: KeyUsage[]\n                ) =>\n                    unwrapKey(\n                        format,\n                        wrappedKey,\n                        wrappedKeyAlgorithm,\n                        target,\n                        unwrappingKeyAlgorithm,\n                        extractable,\n                        keyUsages\n                    );\n\n            case \"exportKey\":\n                return (format: KeyFormat) => exportKey(format, target);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\n/**\n * Generates a counter, with the given length, starting from the count of 1. The nonce is randomized.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AesCtrParams\n * @example\n * ```ts\n * const counter = await AES_CTR.generateCounter();\n * ```\n */\nexport async function generateCounter(\n    counterLength: number = 8\n): Promise<Uint8Array> {\n    const nonce = await getValues(16 - counterLength);\n    const counter = new Uint8Array(16);\n    counter.set([1], 15);\n    counter.set(nonce);\n    return counter;\n}\n\n/**\n * Generate a new AES_CTR key\n * @example\n * ```ts\n * const key = await AES_CTR.generateKey();\n * ```\n */\nexport async function generateKey(\n    algorithm: Omit<params.EnforcedAesKeyGenParams, \"name\"> = {\n        length: 256,\n    },\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<AesCtrProxiedCryptoKey> {\n    const key = await AesShared.generateKey<AesCtrCryptoKey>(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CTR,\n        },\n        extractable,\n        keyUsages\n    );\n    return proxy.proxifyKey<AesCtrCryptoKey, AesCtrProxiedCryptoKey>(handler)(\n        key\n    );\n}\n\n/**\n * Import an AES_CTR key from the specified format\n * @example\n * ```ts\n * const key = await AES_CTR.importKey(\"jwk\", jwk, { length: 256 });\n * ```\n */\nexport async function importKey(\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    algorithm: Omit<params.AesCtrKeyAlgorithm, \"name\">,\n    extractable?: boolean,\n    keyUsages?: KeyUsage[]\n): Promise<AesCtrProxiedCryptoKey> {\n    const importedKey = (await AesShared.importKey(\n        format as any,\n        key as any,\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CTR,\n        },\n        extractable,\n        keyUsages\n    )) as AesCtrCryptoKey;\n    return proxy.proxifyKey<AesCtrCryptoKey, AesCtrProxiedCryptoKey>(handler)(\n        importedKey\n    );\n}\n\n/**\n * Export an AES_CTR key into the specified format\n * @example\n * ```ts\n * const key = await AES_CTR.generateKey();\n * const jwk = await AES_CTR.exportKey(\"jwk\", key.self);\n * ```\n * @example\n * ```ts\n * const key = await AES_CTR.generateKey();\n * const jwk = await key.exportKey(\"jwk\");\n * ```\n */\nexport const exportKey = async (format: KeyFormat, key: AesCtrCryptoKey) =>\n    AesShared.exportKey(format, key);\n\n/**\n * Encrypt with an AES_CTR key\n * @example\n * ```ts\n * const key = await AES_CTR.generateKey();\n * const message = new TextEncoder().encode(\"a message\");\n * const length = 8;\n * const counter = await AES_CTR.generateCounter(length);\n * const data = await AES_CTR.encrypt({length, counter}, key.self, message);\n * ```\n * @example\n * ```ts\n * const key = await AES_CTR.generateKey();\n * const message = new TextEncoder().encode(\"a message\");\n * const length = 8;\n * const counter = await AES_CTR.generateCounter(length);\n * const data = await key.encrypt({length, counter}, message);\n * ```\n */\nexport async function encrypt(\n    algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n    key: AesCtrCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.encrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CTR,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Decrypt with an AES_CTR key\n * @example\n * ```ts\n * const data = await AES_CTR.decrypt({length, counter}, key.self, data);\n * ```\n * @example\n * ```ts\n * const data = await key.decrypt({length, counter}, data);\n * ```\n */\nexport async function decrypt(\n    algorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n    key: AesCtrCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.decrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_CTR,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Wrap another key with an AES_CTR key\n * @example\n * ```ts\n * const kek = await AES_CTR.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_CTR.generateKey();\n * const length = 8;\n * const counter = await AES_CTR.generateCounter(length);\n * const wrappedKey = await AES_CTR.wrapKey(\"raw\", dek.self, kek.self, {length, counter});\n * ```\n * @example\n * ```ts\n * const kek = await AES_CTR.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_CTR.generateKey();\n * const length = 8;\n * const counter = await AES_CTR.generateCounter(length);\n * const wrappedKey = await kek.wrapKey(\"raw\", dek.self, {length, counter});\n * ```\n */\nexport async function wrapKey(\n    format: KeyFormat,\n    key: CryptoKey,\n    wrappingkey: AesCtrCryptoKey,\n    wrapAlgorithm: Omit<params.EnforcedAesCtrParams, \"name\">\n): Promise<ArrayBuffer> {\n    return await AesShared.wrapKey(format as any, key, wrappingkey, {\n        ...wrapAlgorithm,\n        name: Alg.Mode.AES_CTR,\n    });\n}\n\n/**\n * Unwrap a wrapped key using the key encryption key\n * @example\n * ```ts\n * const dek = await AES_CTR.unwrapKey(\"raw\", wrappedKey, {name: \"AES_CTR\"}, kek.self, {length, counter});\n * ```\n * @example\n * ```ts\n * const dek = await kek.unwrapKey(\"raw\", wrappedKey, {name: \"AES_CTR\"}, {length, counter});\n * ```\n */\nexport async function unwrapKey(\n    format: KeyFormat,\n    wrappedKey: BufferSource,\n    wrappedKeyAlgorithm: params.EnforcedImportParams,\n    unwrappingKey: AesCtrCryptoKey,\n    unwrappingKeyAlgorithm: Omit<params.EnforcedAesCtrParams, \"name\">,\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<CryptoKey> {\n    return await AesShared.unwrapKey(\n        format,\n        wrappedKey,\n        wrappedKeyAlgorithm,\n        unwrappingKey,\n        {\n            ...unwrappingKeyAlgorithm,\n            name: Alg.Mode.AES_CTR,\n        },\n        extractable,\n        keyUsages\n    );\n}\n", "/**\n * Code related to AES_GCM mode\n * @module\n */\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport {\n    AesGcmCryptoKey,\n    AesGcmProxiedCryptoKey,\n    AesShared,\n    Alg,\n} from \"./shared.js\";\n\nexport const handler: ProxyHandler<AesGcmCryptoKey> = {\n    get(target: AesGcmCryptoKey, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n\n            case \"encrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n                    data: BufferSource\n                ) => encrypt(algorithm, target, data);\n\n            case \"decrypt\":\n                return (\n                    algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n                    data: BufferSource\n                ) => decrypt(algorithm, target, data);\n\n            case \"wrapKey\":\n                return (\n                    format: KeyFormat,\n                    key: CryptoKey,\n                    wrapAlgorithm: Omit<params.EnforcedAesGcmParams, \"name\">\n                ) => wrapKey(format, key, target, wrapAlgorithm);\n\n            case \"unwrapKey\":\n                return (\n                    format: KeyFormat,\n                    wrappedKey: BufferSource,\n                    wrappedKeyAlgorithm: params.EnforcedImportParams,\n                    unwrappingKeyAlgorithm: Omit<\n                        params.EnforcedAesGcmParams,\n                        \"name\"\n                    >,\n                    extractable?: boolean,\n                    keyUsages?: KeyUsage[]\n                ) =>\n                    unwrapKey(\n                        format,\n                        wrappedKey,\n                        wrappedKeyAlgorithm,\n                        target,\n                        unwrappingKeyAlgorithm,\n                        extractable,\n                        keyUsages\n                    );\n\n            case \"exportKey\":\n                return (format: KeyFormat) => exportKey(format, target);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\n/**\n * Generate a new AES_GCM key\n * @example\n * ```ts\n * const key = await AES_GCM.generateKey();\n * ```\n */\nexport async function generateKey(\n    algorithm: Omit<params.EnforcedAesKeyGenParams, \"name\"> = {\n        length: 256,\n    },\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<AesGcmProxiedCryptoKey> {\n    const key = await AesShared.generateKey<AesGcmCryptoKey>(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_GCM,\n        },\n        extractable,\n        keyUsages\n    );\n    return proxy.proxifyKey<AesGcmCryptoKey, AesGcmProxiedCryptoKey>(handler)(\n        key\n    );\n}\n\n/**\n * Import an AES_GCM key from the specified format\n * @example\n * ```ts\n * const key = await AES_GCM.importKey(\"jwk\", jwk, { length: 256 });\n * ```\n */\nexport async function importKey(\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    algorithm: Omit<params.AesGcmKeyAlgorithm, \"name\">,\n    extractable?: boolean,\n    keyUsages?: KeyUsage[]\n): Promise<AesGcmProxiedCryptoKey> {\n    const importedKey = (await AesShared.importKey(\n        format as any,\n        key as any,\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_GCM,\n        },\n        extractable,\n        keyUsages\n    )) as AesGcmCryptoKey;\n    return proxy.proxifyKey<AesGcmCryptoKey, AesGcmProxiedCryptoKey>(handler)(\n        importedKey\n    );\n}\n\n/**\n * Export an AES_GCM key into the specified format\n * @example\n * ```ts\n * const key = await AES_GCM.generateKey();\n * const jwk = await AES_GCM.exportKey(\"jwk\", key.self);\n * ```\n * @example\n * ```ts\n * const key = await AES_GCM.generateKey();\n * const jwk = await key.exportKey(\"jwk\");\n * ```\n */\nexport const exportKey = async (format: KeyFormat, key: AesGcmCryptoKey) =>\n    AesShared.exportKey(format, key);\n\n/**\n * Encrypt with an AES_GCM key\n * @example\n * ```ts\n * const iv = await Random.IV.generate();\n * const key = await AES_GCM.generateKey();\n * const message = new TextEncoder().encode(\"a message\");\n * const data = await AES_GCM.encrypt({iv}, key.self, message);\n * ```\n * @example\n * ```ts\n * const iv = await Random.IV.generate();\n * const key = await AES_GCM.generateKey();\n * const message = new TextEncoder().encode(\"a message\");\n * const data = await key.encrypt({iv}, message);\n * ```\n */\nexport async function encrypt(\n    algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n    key: AesGcmCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.encrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_GCM,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Decrypt with an AES_GCM key\n * @example\n * ```ts\n * const key = await AES_GCM.generateKey();\n * const data = await AES_GCM.decrypt({iv}, key.self, data);\n * ```\n * @example\n * ```ts\n * const key = await AES_GCM.generateKey();\n * const data = await key.decrypt({iv}, data);\n * ```\n */\nexport async function decrypt(\n    algorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n    key: AesGcmCryptoKey,\n    data: BufferSource\n): Promise<ArrayBuffer> {\n    return await AesShared.decrypt(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_GCM,\n        },\n        key,\n        data\n    );\n}\n\n/**\n * Wrap another key with an AES_GCM key\n * @example\n * ```ts\n * const iv = await Random.IV.generate();\n * const kek = await AES_GCM.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_GCM.generateKey();\n * const wrappedKey = await AES_GCM.wrapKey(\"raw\", dek.self, kek.self, {iv});\n * ```\n * @example\n * ```ts\n * const iv = await Random.IV.generate();\n * const kek = await AES_GCM.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_GCM.generateKey();\n * const wrappedKey = await kek.wrapKey(\"raw\", dek.self, {iv});\n * ```\n */\nexport async function wrapKey(\n    format: KeyFormat,\n    key: CryptoKey,\n    wrappingkey: AesGcmCryptoKey,\n    wrapAlgorithm: Omit<params.EnforcedAesGcmParams, \"name\">\n): Promise<ArrayBuffer> {\n    return await AesShared.wrapKey(format as any, key, wrappingkey, {\n        ...wrapAlgorithm,\n        name: Alg.Mode.AES_GCM,\n    });\n}\n\n/**\n * Unwrap a wrapped key using the key encryption key\n * @example\n * ```ts\n * const dek = await AES_GCM.unwrapKey(\"raw\", wrappedKey, {name: \"AES_GCM\"}, kek, {iv});\n * ```\n * @example\n * ```ts\n * const dek = await kek.unwrapKey(\"raw\", wrappedKey, {name: \"AES_GCM\"}, {iv});\n * ```\n */\nexport async function unwrapKey(\n    format: KeyFormat,\n    wrappedKey: BufferSource,\n    wrappedKeyAlgorithm: params.EnforcedImportParams,\n    unwrappingKey: AesGcmCryptoKey,\n    unwrappingKeyAlgorithm: Omit<params.EnforcedAesGcmParams, \"name\">,\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<CryptoKey> {\n    return await AesShared.unwrapKey(\n        format,\n        wrappedKey,\n        wrappedKeyAlgorithm,\n        unwrappingKey,\n        {\n            ...unwrappingKeyAlgorithm,\n            name: Alg.Mode.AES_GCM,\n        },\n        extractable,\n        keyUsages\n    );\n}\n", "/**\n * Code related to AES_KW mode\n * @module\n */\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport {\n    AesKwCryptoKey,\n    AesKwProxiedCryptoKey,\n    AesShared,\n    Alg,\n} from \"./shared.js\";\n\nexport const handler: ProxyHandler<AesKwCryptoKey> = {\n    get(target: AesKwCryptoKey, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n\n            case \"wrapKey\":\n                return (format: KeyFormat, key: CryptoKey) =>\n                    wrapKey(format, key, target);\n            case \"unwrapKey\":\n                return (\n                    format: KeyFormat,\n                    wrappedKey: BufferSource,\n                    wrappedKeyAlgorithm: params.EnforcedImportParams,\n                    extractable?: boolean,\n                    keyUsages?: KeyUsage[]\n                ) =>\n                    unwrapKey(\n                        format,\n                        wrappedKey,\n                        wrappedKeyAlgorithm,\n                        target,\n                        extractable,\n                        keyUsages\n                    );\n            case \"exportKey\":\n                return (format: KeyFormat) => exportKey(format, target);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\n/**\n * Generate a new AES_KW key\n * @example\n * ```ts\n * const key = await AES_KW.generateKey();\n * ```\n */\nexport async function generateKey(\n    algorithm: Omit<params.EnforcedAesKeyGenParams, \"name\"> = {\n        length: 256,\n    },\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<AesKwProxiedCryptoKey> {\n    const key = (await AesShared.generateKey(\n        {\n            ...algorithm,\n            name: Alg.Mode.AES_KW,\n        },\n        extractable,\n        keyUsages\n    )) as AesKwCryptoKey;\n    return proxy.proxifyKey<AesKwCryptoKey, AesKwProxiedCryptoKey>(handler)(\n        key\n    );\n}\n\n/**\n * Import an AES_KW key from the specified format\n * @example\n * ```ts\n * const key = await AES_KW.importKey(\"jwk\", jwk);\n * ```\n */\nexport async function importKey(\n    format: KeyFormat,\n    key: BufferSource | JsonWebKey,\n    extractable?: boolean,\n    keyUsages?: KeyUsage[]\n): Promise<AesKwProxiedCryptoKey> {\n    const importedKey = (await AesShared.importKey(\n        format as any,\n        key as any,\n        {\n            name: Alg.Mode.AES_KW,\n        },\n        extractable,\n        keyUsages\n    )) as AesKwCryptoKey;\n    return proxy.proxifyKey<AesKwCryptoKey, AesKwProxiedCryptoKey>(handler)(\n        importedKey\n    );\n}\n\n/**\n * Export an AES_KW key into the specified format\n * @example\n * ```ts\n * const jwk = await AES_KW.exportKey(\"jwk\", key.self);\n * ```\n * @example\n * ```ts\n * const jwk = await key.exportKey(\"jwk\");\n * ```\n */\nexport const exportKey = async (format: KeyFormat, key: AesKwCryptoKey) =>\n    AesShared.exportKey(format, key);\n\n/**\n * Wrap another key with an AES_KW key\n * @example\n * ```ts\n * const kek = await AES_KW.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_GCM.generateKey();\n * const wrappedKey = await AES_KW.wrapKey(\"raw\", dek.self, kek.self);\n * ```\n * @example\n * ```ts\n * const kek = await AES_KW.generateKey({length: 256}, true, ['wrapKey', 'unwrapKey']);\n * const dek = await AES_GCM.generateKey();\n * const wrappedKey = await kek.wrapKey(\"raw\", dek.self);\n * ```\n */\nexport async function wrapKey(\n    format: KeyFormat,\n    key: CryptoKey,\n    wrappingkey: AesKwCryptoKey\n): Promise<ArrayBuffer> {\n    return await AesShared.wrapKey(format as any, key, wrappingkey, {\n        name: Alg.Mode.AES_KW,\n    });\n}\n\n/**\n * Unwrap a wrapped key using the key encryption key\n * @example\n * ```ts\n * const dek = await AES_KW.unwrapKey(\"raw\", wrappedKey, {name: \"AES_GCM\"}, kek.self);\n * ```\n * @example\n * ```ts\n * const dek = await kek.unwrapKey(\"raw\", wrappedKey, {name: \"AES_GCM\"});\n * ```\n */\nexport async function unwrapKey(\n    format: KeyFormat,\n    wrappedKey: BufferSource,\n    wrappedKeyAlgorithm: params.EnforcedImportParams,\n    unwrappingKey: AesKwCryptoKey,\n    extractable: boolean = true,\n    keyUsages?: KeyUsage[]\n): Promise<CryptoKey> {\n    return await AesShared.unwrapKey(\n        format,\n        wrappedKey,\n        wrappedKeyAlgorithm,\n        unwrappingKey,\n        {\n            name: Alg.Mode.AES_KW,\n        },\n        extractable,\n        keyUsages\n    );\n}\n", "/**\n * Code related to PBKDF2\n * @module\n */\nimport { handler as AesCbcHandler } from \"../aes/aes_cbc.js\";\nimport { handler as AesCtrHandler } from \"../aes/aes_ctr.js\";\nimport { handler as AesGcmHandler } from \"../aes/aes_gcm.js\";\nimport { handler as AesKwHandler } from \"../aes/aes_kw.js\";\nimport {\n    Alg as AesAlg,\n    AesCbcCryptoKey,\n    AesCbcProxiedCryptoKey,\n    AesCtrCryptoKey,\n    AesCtrProxiedCryptoKey,\n    AesGcmCryptoKey,\n    AesGcmProxiedCryptoKey,\n    AesKwCryptoKey,\n    AesKwProxiedCryptoKey,\n    AesProxiedCryptoKeys,\n} from \"../aes/shared.js\";\nimport {\n    Alg as HmacAlg,\n    HmacCryptoKey,\n    HmacProxiedCryptoKey,\n    handler as hmacHandler,\n} from \"../hmac/index.js\";\nimport * as params from \"../params.js\";\nimport * as proxy from \"../proxy.js\";\nimport { Alg as SHA } from \"../sha/shared.js\";\nimport {\n    Alg,\n    KdfShared,\n    Pbkdf2KeyMaterial,\n    Pbkdf2ProxiedKeyMaterial,\n} from \"./shared.js\";\n\nconst handler: ProxyHandler<Pbkdf2KeyMaterial> = {\n    get(target: Pbkdf2KeyMaterial, prop: string) {\n        switch (prop) {\n            case \"self\":\n                return target;\n            case \"deriveKey\":\n                return (\n                    algorithm: Omit<\n                        params.EnforcedPbkdf2Params,\n                        \"name\" | \"iterations\"\n                    >,\n                    derivedKeyType:\n                        | params.EnforcedAesKeyGenParams\n                        | params.EnforcedHmacKeyGenParams,\n                    extractable?: boolean,\n                    keyUsages?: KeyUsage[]\n                ) =>\n                    deriveKey(\n                        algorithm,\n                        target,\n                        derivedKeyType,\n                        extractable,\n                        keyUsages\n                    );\n            case \"deriveBits\":\n                return (\n                    algorithm: Omit<params.EnforcedPbkdf2Params, \"name\">,\n                    length: number\n                ) => deriveBits(algorithm, target, length);\n        }\n\n        return Reflect.get(target, prop);\n    },\n};\n\nconst hashIterations: Record<SHA.Variants, number> = {\n    \"SHA-1\": 1_300_000,\n    \"SHA-256\": 600_000,\n    \"SHA-384\": 600_000,\n    \"SHA-512\": 210_000,\n};\n\n/**\n * Generate key material for deriving\n * @example\n * ```ts\n * const keyMaterial = await PBKDF2.generateKeyMaterial(\"raw\", new TextEncoder().encode(\"could_be_a_little_entropy\"));\n * ```\n */\nexport const generateKeyMaterial = async (\n    format: KeyFormat,\n    key: BufferSource,\n    extractable?: boolean\n): Promise<Pbkdf2ProxiedKeyMaterial> => {\n    const keyMaterial = await KdfShared.generateKeyMaterial<Pbkdf2KeyMaterial>(\n        format,\n        key,\n        Alg.Variant.PBKDF2,\n        extractable\n    );\n\n    return proxy.proxifyKey<Pbkdf2KeyMaterial, Pbkdf2ProxiedKeyMaterial>(\n        handler\n    )(keyMaterial);\n};\n\n/**\n * Derive a shared key from PBKDF2 key material\n * @example\n * ```ts\n * const hmacParams: params.EnforcedHmacKeyGenParams = {\n *     name: Authentication.Alg.Code.HMAC,\n *     hash: SHA.Alg.Variant.SHA_512,\n *     length: 512,\n * };\n * let key = await PBKDF2.deriveKey(\n *     { hash: \"SHA512\" },\n *     keyMaterial,\n *     hmacParams\n * );\n * ```\n * @example\n * ```ts\n * const hmacParams: params.EnforcedHmacKeyGenParams = {\n *     name: Authentication.Alg.Code.HMAC,\n *     hash: SHA.Alg.Variant.SHA_512,\n *     length: 512,\n * };\n * const keyMaterial = await PBKDF2.generateKeyMaterial(\n *     \"raw\",\n *     await Random.getValues(16)\n * );\n * let key = await keyMaterial.deriveKey(\n *     { hash: \"SHA512\" },\n *     hmacParams\n * );\n * ```\n * @example\n * ```ts\n * const keyMaterial = await PBKDF2.generateKeyMaterial(\n *     \"raw\",\n *     await Random.getValues(16)\n * );\n * let key = await PBKDF2.deriveKey(\n *     {\n *         hash: \"SHA-256\",\n *         salt,\n *     },\n *     keyMaterial.self,\n *     {\n *         name: \"AES-GCM\",\n *         length: 256,\n *     }\n * );\n * ```\n * @example\n * ```ts\n * const key = await keyMaterial.deriveKey(\n *     {\n *         hash: \"SHA-256\",\n *         salt,\n *     },\n *     {\n *         name: \"AES-GCM\",\n *         length: 256,\n *     }\n * );\n * ```\n */\nexport const deriveKey = async (\n    algorithm: Omit<params.EnforcedPbkdf2Params, \"name\" | \"iterations\">,\n    baseKey: Pbkdf2KeyMaterial,\n    derivedKeyType:\n        | params.EnforcedAesKeyGenParams\n        | params.EnforcedHmacKeyGenParams,\n    extractable?: boolean,\n    keyUsages?: KeyUsage[]\n): Promise<HmacProxiedCryptoKey | AesProxiedCryptoKeys> => {\n    const derived = await KdfShared.deriveKey(\n        {\n            ...algorithm,\n            name: Alg.Variant.PBKDF2,\n            iterations: hashIterations[\n                algorithm.hash\n            ] as params.EnforcedPbkdf2Params[\"iterations\"],\n        },\n        baseKey,\n        derivedKeyType,\n        extractable,\n        keyUsages\n    );\n\n    switch (derivedKeyType.name) {\n        case HmacAlg.Code.HMAC:\n            return proxy.proxifyKey<HmacCryptoKey, HmacProxiedCryptoKey>(\n                hmacHandler\n            )(derived as HmacCryptoKey);\n        case AesAlg.Mode.AES_CBC:\n            return proxy.proxifyKey<AesCbcCryptoKey, AesCbcProxiedCryptoKey>(\n                AesCbcHandler\n            )(derived as AesCbcCryptoKey);\n        case AesAlg.Mode.AES_CTR:\n            return proxy.proxifyKey<AesCtrCryptoKey, AesCtrProxiedCryptoKey>(\n                AesCtrHandler\n            )(derived as AesCtrCryptoKey);\n        case AesAlg.Mode.AES_GCM:\n            return proxy.proxifyKey<AesGcmCryptoKey, AesGcmProxiedCryptoKey>(\n                AesGcmHandler\n            )(derived as AesGcmCryptoKey);\n        case AesAlg.Mode.AES_KW:\n            return proxy.proxifyKey<AesKwCryptoKey, AesKwProxiedCryptoKey>(\n                AesKwHandler\n            )(derived as AesKwCryptoKey);\n    }\n\n    throw new Error(\"Invalid alg\");\n};\n\n/**\n * Derive a number bits with a given key material\n * @example\n * ```ts\n * const bits = await PBKDF2.deriveBits(\n *      { hash: \"SHA-512\" },\n *      keyMaterial,\n *      128\n * );\n * ```\n * @example\n * ```ts\n * const bits = await keyMaterial.deriveBits(\n *      { hash: \"SHA-512\" },\n *      128\n * );\n * ```\n */\nexport const deriveBits = (\n    algorithm: Omit<params.EnforcedPbkdf2Params, \"name\" | \"iterations\">,\n    baseKey: Pbkdf2KeyMaterial,\n    length: number\n) =>\n    KdfShared.deriveBits(\n        {\n            ...algorithm,\n            name: Alg.Variant.PBKDF2,\n            iterations: hashIterations[\n                algorithm.hash\n            ] as params.EnforcedPbkdf2Params[\"iterations\"],\n        },\n        baseKey,\n        length\n    );\n", "/**\n * Code related to SHA_256\n * @module\n */\n\nimport * as WebCrypto from \"../webcrypto.js\";\nimport { Alg, Sha256ArrayBuffer, ShaShared } from \"./shared.js\";\n\n/**\n * Get the digest of the buffer\n * @example\n * ```ts\n * const buffer = new TextEncoder().encode(\"a file\");\n * const digest = SHA_256.digest(buffer);\n * ```\n */\nexport const digest = async (data: BufferSource) =>\n    WebCrypto.digest<Sha256ArrayBuffer>(Alg.Variant.SHA_256, data);\n\n/**\n * Get the hex string of the digest\n * @example\n * ```ts\n * const hash = SHA_256.hexify(digest);\n * ```\n */\nexport const hexify = (digest: Sha256ArrayBuffer) => ShaShared.hexify(digest);\n", "/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n\n// ---------------------------------------------------------------------------\n// Specific encodings\n// ---------------------------------------------------------------------------\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse(string, opts) {\n    return _parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify(data, opts) {\n    return _stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    return _parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify(data, opts) {\n    return _stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse(string, opts) {\n    return _parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify(data, opts) {\n    return _stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse(string, opts) {\n    return _parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify(data, opts) {\n    return _stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse(string, opts) {\n    return _parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify(data, opts) {\n    return _stringify(data, base64UrlEncoding, opts);\n  }\n};\n\n// ---------------------------------------------------------------------------\n// Codec implementation\n// ---------------------------------------------------------------------------\n\nvar codec = {\n  parse: _parse,\n  stringify: _stringify\n};\nfunction _parse(string, encoding, opts) {\n  var _opts$out;\n  if (opts === void 0) {\n    opts = {};\n  }\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  }\n\n  // The string must have a whole number of bytes:\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  }\n\n  // Count the padding bytes:\n  var end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n\n    // If we get a whole number of bytes, there is too much padding:\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  }\n\n  // Allocate the output:\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0);\n\n  // Parse the data:\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  var written = 0; // Next byte to write\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    }\n\n    // Append the bits to the buffer:\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits;\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n}\nfunction _stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  var _opts = opts,\n    _opts$pad = _opts.pad,\n    pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n  var buffer = 0; // Bits waiting to be written out, MSB first\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8;\n\n    // Write out as much as we can:\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n  return out;\n}\n\nexport { base16, base32, base32hex, base64, base64url, codec };\n", "import { base64url } from 'rfc4648';\nexport function decode(s) {\n    return new TextDecoder().decode(base64url.parse(s, { loose: true }));\n}\n", "import { base64url } from 'rfc4648';\nexport function encode(s) {\n    return base64url.stringify(new TextEncoder().encode(s), { pad: false });\n}\n", "import {\n    decode as _fromBase64Url,\n    encode as _toBase64Url,\n} from \"@cfworker/base64url\";\n\nexport function concatBuffer(...buffers: ArrayBuffer[]) {\n    const length = buffers.reduce((acc, b) => acc + b.byteLength, 0);\n    const tmp = new Uint8Array(length);\n\n    let prev = 0;\n    for (let buffer of buffers) {\n        tmp.set(new Uint8Array(buffer), prev);\n        prev += buffer.byteLength;\n    }\n\n    return tmp.buffer;\n}\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nexport const encode = encoder.encode.bind(encoder);\nexport const decode = decoder.decode.bind(decoder);\n\nexport const toBase64Url = _toBase64Url;\nexport const fromBase64Url = _fromBase64Url;\n\nexport const stringToBuffer = (str: string) =>\n    Uint8Array.from(str, (e) => e.charCodeAt(0)).buffer;\n\nexport const bufferToString = (buffer: ArrayBuffer) =>\n    String.fromCharCode(...new Uint8Array(buffer));\n\nexport const safeEncode = (data: string): ArrayBuffer =>\n    stringToBuffer(fromBase64Url(data));\nexport const safeDecode = (data: ArrayBuffer): string =>\n    toBase64Url(bufferToString(data));\n", "import type { AesGcmProxiedCryptoKey } from \"@nfen/webcrypto-ts/lib/aes/shared\";\nimport { Alg as AesAlg } from \"@nfen/webcrypto-ts/lib/aes/shared\";\nimport * as PBKDF2 from \"@nfen/webcrypto-ts/lib/kdf/pbkdf\";\nimport { getValues, IV, Salt } from \"@nfen/webcrypto-ts/lib/random\";\nimport { digest } from \"@nfen/webcrypto-ts/lib/sha/sha_256\";\nimport { Alg as ShaAlg } from \"@nfen/webcrypto-ts/lib/sha/shared\";\nimport { concatBuffer } from \"./utils.js\";\n\nexport async function hashPassword(password: ArrayBuffer) {\n    return await digest(password);\n}\n\nexport async function encrypt({\n    key,\n    plaintext,\n}: {\n    key: AesGcmProxiedCryptoKey;\n    plaintext: ArrayBuffer;\n}) {\n    const iv = await IV.generate(16);\n    const ciphertext = await key.encrypt({ iv }, plaintext);\n    return {\n        iv,\n        ciphertext,\n    };\n}\nexport async function decrypt({\n    key,\n    iv,\n    ciphertext,\n}: {\n    key: AesGcmProxiedCryptoKey;\n    iv: ArrayBuffer;\n    ciphertext: ArrayBuffer;\n}) {\n    return await key.decrypt({ iv }, ciphertext);\n}\n\nexport interface KeyDerivationParams {\n    salt: ArrayBuffer;\n    entropy: ArrayBuffer;\n    password: ArrayBuffer;\n}\nexport interface KeyGenerationMaterials {\n    salt: ArrayBuffer;\n    entropy: ArrayBuffer;\n    key: AesGcmProxiedCryptoKey;\n}\n\nexport async function generateKey(\n    password: ArrayBuffer\n): Promise<KeyGenerationMaterials> {\n    const salt = await Salt.generate(16);\n    const entropy = await getValues(16);\n    const key = await deriveKey({ salt, entropy, password });\n    return { salt, entropy, key };\n}\n\nexport async function deriveKey({\n    salt,\n    entropy,\n    password,\n}: KeyDerivationParams) {\n    const keyMaterial = await PBKDF2.generateKeyMaterial(\n        \"raw\",\n        concatBuffer(entropy, password)\n    );\n\n    return (await keyMaterial.deriveKey(\n        {\n            hash: ShaAlg.Variant.SHA_256,\n            salt,\n        },\n        {\n            name: AesAlg.Mode.AES_GCM,\n            length: 256,\n        }\n    )) as AesGcmProxiedCryptoKey;\n}\n", "export const loader = document.querySelector(\"section#loader\") as HTMLElement;\nexport const error = document.querySelector(\"aside#error\") as HTMLElement;\n\nexport namespace Encrypt {\n    export const section = document.querySelector(\n        \"section#encrypt\"\n    ) as HTMLElement;\n    export const form = section.querySelector(\n        \"form#encrypt-form\"\n    ) as HTMLFormElement;\n    export const formBtn = form.querySelector(\"button\") as HTMLButtonElement;\n    export const password = form.querySelector(\n        \"input#encrypt-password\"\n    ) as HTMLInputElement;\n\n    export const secret = form.querySelector(\n        \"textarea#encrypt-secret\"\n    ) as HTMLTextAreaElement;\n    export const aside = section.querySelector(\n        \"aside#encrypt-aside\"\n    ) as HTMLElement;\n    export const url = aside.querySelector(\n        \"input#encrypt-url\"\n    ) as HTMLInputElement;\n    export const copy = aside.querySelector(\n        \"button#encrypt-url-btn\"\n    ) as HTMLButtonElement;\n}\n\nexport namespace Decrypt {\n    export const section = document.querySelector(\n        \"section#decrypt\"\n    ) as HTMLElement;\n\n    export const form = section.querySelector(\n        \"form#decrypt-form\"\n    ) as HTMLFormElement;\n\n    export const formBtn = form.querySelector(\"button\") as HTMLButtonElement;\n    export const password = section.querySelector(\n        \"input#decrypt-password\"\n    ) as HTMLInputElement;\n\n    export const aside = section.querySelector(\n        \"aside#decrypt-aside\"\n    ) as HTMLElement;\n    export const secret = aside.querySelector(\n        \"textarea#decrypt-secret\"\n    ) as HTMLTextAreaElement;\n\n    export const copy = aside.querySelector(\n        \"button#decrypt-secret-btn\"\n    ) as HTMLButtonElement;\n}\n", "import * as utils from \"./utils.js\";\n\nexport interface HashPayload {\n    salt: ArrayBuffer;\n    entropy: ArrayBuffer;\n    id: string;\n}\n\nexport function decodeHashPayload({ salt, entropy, id }: HashPayload) {\n    const payload = JSON.stringify({\n        salt: utils.safeDecode(salt),\n        entropy: utils.safeDecode(entropy),\n        id,\n    });\n    return utils.toBase64Url(payload);\n}\n\nexport function encodeHashPayload(): HashPayload {\n    const { salt, entropy, id } = JSON.parse(\n        utils.fromBase64Url(window.location.hash.slice(1))\n    );\n    return {\n        salt: utils.safeEncode(salt),\n        entropy: utils.safeEncode(entropy),\n        id,\n    };\n}\n", "import { API } from \"./api.js\";\nimport * as Crypto from \"./crypto.js\";\nimport * as dom from \"./dom.js\";\nimport * as url from \"./url.js\";\nimport { decode, encode } from \"./utils.js\";\n\nlet cache = (function () {\n    class Cache {\n        private cache: Map<string, API.RetrieveUsableResponse> = new Map();\n        private counter: number = 0;\n\n        get(key: string): API.RetrieveUsableResponse | null {\n            if (++this.counter >= 30) {\n                this.clear();\n                throw new Error(\"Too many attempts.\");\n            }\n            return this.cache.get(key) || null;\n        }\n        has(key: string): boolean {\n            return this.cache.has(key);\n        }\n        set(key: string, value: API.RetrieveUsableResponse) {\n            if (!this.cache.has(key)) {\n                this.cache.set(key, value);\n            }\n        }\n        clear() {\n            this.cache.clear();\n            this.counter = 0;\n        }\n    }\n\n    return new Cache();\n})();\n\nasync function handleDecryption(e: SubmitEvent) {\n    hideError();\n    e.preventDefault();\n    if (dom.Decrypt.form.reportValidity() && window.location.hash) {\n        try {\n            dom.Decrypt.formBtn.setAttribute(\"disabled\", \"disabled\");\n            const { id, salt, entropy } = url.encodeHashPayload();\n\n            let response: API.RetrieveUsableResponse;\n            if (!cache.has(id)) {\n                response = await API.retrieve({ id });\n                cache.set(id, response);\n            } else {\n                response = cache.get(id) as API.RetrieveUsableResponse;\n            }\n\n            const { iv, ciphertext } = response;\n            const password = await Crypto.hashPassword(\n                encode(dom.Decrypt.password.value.trim())\n            );\n            const key = await Crypto.deriveKey({\n                salt,\n                entropy,\n                password,\n            });\n            const plaintext = await Crypto.decrypt({ key, iv, ciphertext });\n\n            dom.Decrypt.secret.value = decode(plaintext);\n            dom.Decrypt.form.classList.add(\"hidden\");\n            dom.Decrypt.aside.classList.remove(\"hidden\");\n            history.replaceState(\n                \"\",\n                document.title,\n                window.location.pathname + window.location.search\n            );\n\n            cache.clear();\n        } catch (err: any) {\n            showError(err);\n        } finally {\n            dom.Decrypt.formBtn.removeAttribute(\"disabled\");\n        }\n    }\n    return false;\n}\n\nasync function handleEncryption(e: SubmitEvent) {\n    hideError();\n    e.preventDefault();\n    if (dom.Encrypt.form.reportValidity()) {\n        try {\n            dom.Encrypt.formBtn.setAttribute(\"disabled\", \"disabled\");\n            const password = await Crypto.hashPassword(\n                encode(dom.Encrypt.password.value.trim())\n            );\n            const { key, salt, entropy } = await Crypto.generateKey(password);\n            const plaintext = encode(dom.Encrypt.secret.value);\n            const payload = await Crypto.encrypt({ key, plaintext });\n            const { id } = await API.store(payload);\n            const hash = url.decodeHashPayload({ salt, entropy, id });\n            dom.Encrypt.url.value = `${location.origin}#${hash}`;\n            dom.Encrypt.form.classList.add(\"hidden\");\n            dom.Encrypt.aside.classList.remove(\"hidden\");\n        } catch (err: any) {\n            showError(err);\n        } finally {\n            dom.Encrypt.formBtn.removeAttribute(\"disabled\");\n        }\n    }\n    return false;\n}\n\nconst copy = (input: HTMLInputElement | HTMLTextAreaElement) =>\n    function onCopy(e: Event) {\n        if (e.target) {\n            // @ts-ignore\n            const $defaultMessage =\n                input.parentNode?.querySelector(\".default-message\");\n            // @ts-ignore\n            const $successMessage =\n                input.parentNode?.querySelector(\".success-message\");\n\n            navigator.clipboard.writeText(input.value).then(() => {\n                $defaultMessage?.classList.add(\"hidden\");\n                $successMessage?.classList.remove(\"hidden\");\n\n                // reset to default state\n                setTimeout(() => {\n                    $defaultMessage?.classList.remove(\"hidden\");\n                    $successMessage?.classList.add(\"hidden\");\n                }, 2000);\n            });\n        }\n    };\n\nfunction showError(e: any) {\n    const text = dom.error.querySelector(\"#error-text\");\n    if (text) {\n        text.textContent = e?.message;\n    }\n    dom.error.classList.remove(\"hidden\");\n}\n\nfunction hideError() {\n    dom.error.classList.add(\"hidden\");\n}\n\nfunction setup() {\n    dom.Encrypt.form.reset();\n    dom.Decrypt.form.reset();\n\n    dom.Encrypt.form.addEventListener(\"submit\", handleEncryption);\n    dom.Decrypt.form.addEventListener(\"submit\", handleDecryption);\n\n    dom.Encrypt.url.value = \"\";\n    dom.Decrypt.secret.value = \"\";\n\n    if (window.location.hash) {\n        dom.Decrypt.section.classList.remove(\"hidden\");\n    } else {\n        dom.Encrypt.section.classList.remove(\"hidden\");\n    }\n\n    dom.Encrypt.copy.addEventListener(\"click\", copy(dom.Encrypt.url));\n    dom.Decrypt.copy.addEventListener(\"click\", copy(dom.Decrypt.secret));\n\n    dom.loader.classList.add(\"hidden\");\n    dom.error.querySelector(\"button\")?.addEventListener(\"click\", hideError);\n}\n\nsetup();\n"],
  "mappings": "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",
  "names": ["makeRequest", "endpoint", "payload", "API", "retrieve", "response", "iv", "ciphertext", "error", "store", "CryptoLoader", "_crypto", "encrypt", "algorithm", "key", "data", "decrypt", "sign", "verify", "signature", "deriveKey", "derivedKeyType", "extractable", "keyUsages", "deriveBits", "baseKey", "length", "wrapKey", "format", "wrappingKey", "wrapAlgorithm", "unwrapKey", "wrappedKey", "unwrappingKey", "unwrapAlgorithm", "unwrappedKeyAlgorithm", "exportKey", "importKey", "generateKey", "digest", "Alg", "Variant", "Curve", "EcShared", "generateKey", "algorithm", "extractable", "keyUsages", "getKeyUsagePairsByAlg", "importKey", "format", "key", "exportKey", "proxifyKey", "handler", "key", "Alg", "Variant", "ShaShared", "digest", "b", "handler", "target", "prop", "data", "sign", "signature", "verify", "format", "exportKey", "Alg", "Code", "exportKey", "format", "key", "sign", "data", "Alg", "verify", "signature", "Alg", "Variant", "KdfShared", "generateKeyMaterial", "format", "key", "algorithm", "extractable", "importKey", "DeriveKeyUsagePair", "deriveKey", "baseKey", "derivedKeyType", "keyUsages", "getKeyUsagePairsByAlg", "deriveBits", "length", "Alg", "Variant", "RsaShared", "generateKey", "algorithm", "extractable", "keyUsages", "getKeyUsagePairsByAlg", "importKey", "format", "key", "exportKey", "sign", "data", "verify", "signature", "KeyFormats", "KeyUsages", "EncryptionKeyUsagePair", "SigningKeyUsagePair", "WrappingKeyUsagePair", "DeriveKeyUsagePair", "getKeyUsagePairsByAlg", "alg", "Alg", "Alg", "Mode", "AesShared", "generateKey", "algorithm", "extractable", "keyUsages", "getKeyUsagePairsByAlg", "importKey", "format", "key", "exportKey", "encrypt", "data", "decrypt", "wrapKey", "wrappingkey", "wrapAlgorithm", "unwrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKey", "unwrappingKeyAlgorithm", "handler", "target", "prop", "algorithm", "data", "encrypt", "decrypt", "format", "key", "wrapAlgorithm", "wrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "unwrapKey", "exportKey", "exportKey", "format", "key", "AesShared", "encrypt", "algorithm", "data", "Alg", "decrypt", "wrapKey", "wrappingkey", "wrapAlgorithm", "unwrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKey", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "getValues", "length", "_crypto", "IV", "generate", "Salt", "UUID", "handler", "target", "prop", "algorithm", "data", "encrypt", "decrypt", "format", "key", "wrapAlgorithm", "wrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "unwrapKey", "exportKey", "exportKey", "format", "key", "AesShared", "encrypt", "algorithm", "data", "Alg", "decrypt", "wrapKey", "wrappingkey", "wrapAlgorithm", "unwrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKey", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "handler", "target", "prop", "algorithm", "data", "encrypt", "decrypt", "format", "key", "wrapAlgorithm", "wrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "unwrapKey", "exportKey", "exportKey", "format", "key", "AesShared", "encrypt", "algorithm", "data", "Alg", "decrypt", "wrapKey", "wrappingkey", "wrapAlgorithm", "unwrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKey", "unwrappingKeyAlgorithm", "extractable", "keyUsages", "handler", "target", "prop", "format", "key", "wrapKey", "wrappedKey", "wrappedKeyAlgorithm", "extractable", "keyUsages", "unwrapKey", "exportKey", "exportKey", "format", "key", "AesShared", "wrapKey", "wrappingkey", "Alg", "unwrapKey", "wrappedKey", "wrappedKeyAlgorithm", "unwrappingKey", "extractable", "keyUsages", "handler", "target", "prop", "algorithm", "derivedKeyType", "extractable", "keyUsages", "deriveKey", "length", "deriveBits", "hashIterations", "generateKeyMaterial", "format", "key", "keyMaterial", "KdfShared", "Alg", "proxifyKey", "baseKey", "derived", "digest", "data", "Alg", "base64UrlEncoding", "base64url", "string", "opts", "_parse", "base64UrlEncoding", "data", "_stringify", "_parse", "string", "encoding", "opts", "_opts$out", "i", "end", "out", "bits", "buffer", "written", "_i", "value", "_stringify", "data", "_opts", "_opts$pad", "pad", "mask", "decode", "s", "base64url", "encode", "s", "base64url", "concatBuffer", "buffers", "length", "acc", "b", "tmp", "prev", "buffer", "encoder", "decoder", "encode", "decode", "toBase64Url", "fromBase64Url", "stringToBuffer", "str", "e", "bufferToString", "safeEncode", "data", "safeDecode", "hashPassword", "password", "digest", "encrypt", "key", "plaintext", "iv", "IV", "ciphertext", "decrypt", "generateKey", "salt", "Salt", "entropy", "getValues", "deriveKey", "generateKeyMaterial", "concatBuffer", "Alg", "loader", "error", "Encrypt", "Decrypt", "decodeHashPayload", "salt", "entropy", "id", "payload", "safeDecode", "toBase64Url", "encodeHashPayload", "fromBase64Url", "safeEncode", "cache", "Cache", "key", "value", "handleDecryption", "hideError", "Decrypt", "id", "salt", "entropy", "encodeHashPayload", "response", "API", "iv", "ciphertext", "password", "hashPassword", "encode", "deriveKey", "plaintext", "decrypt", "decode", "err", "showError", "handleEncryption", "Encrypt", "generateKey", "payload", "encrypt", "hash", "decodeHashPayload", "copy", "input", "e", "$defaultMessage", "$successMessage", "text", "error", "setup", "loader"]
}
